## API Report File for "grainjs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export function attr(attrName: string, attrValueObs: BindableValue<string | null | undefined>): DomElementMethod;

// @public
export function attrElem(elem: Element, attrName: string, attrValue: string | null | undefined): void;

// @public (undocumented)
export function attrs(attrsObj: IAttrObj): DomElementMethod;

// @public
export function attrsElem(elem: Element, attrsObj: IAttrObj): void;

// @public (undocumented)
export function autoDispose(disposable: IDisposable | null): ((elem: Node) => void) | undefined;

// @public
export function autoDisposeElem(elem: Node, disposable: IDisposable | null): void;

// @public
export class BaseObservable<T> {
    constructor(value: T);
    addListener(callback: (val: T, prev: T) => void, optContext?: object): Listener;
    dispose(): void;
    // (undocumented)
    protected _disposeOwned(arg?: any): void;
    get(): T;
    // Warning: (ae-forgotten-export) The symbol "DepItem" needs to be exported by the entry point index.d.ts
    //
    // @internal
    _getDepItem(): DepItem | null;
    hasListeners(): boolean;
    isDisposed(): boolean;
    set(value: T): void;
    setAndTrigger(value: T): void;
    setListenerChangeCB(changeCB: (hasListeners: boolean) => void, optContext?: any): void;
    // @internal
    protected _setWithArg(value: T, arg: any): void;
}

// @public
export type BindableValue<T> = BaseObservable<T> | ComputedCallback<T> | T | IKnockoutReadObservable<T>;

// @public
export function bindB<R>(func: (...args: any[]) => R, b: any[]): () => R;

// @public
export function bindBU<R>(func: (...args: any[]) => R, b: any[]): (arg: any) => R;

// @public
export function bindUB<U, R>(func: (arg: U, ...args: any[]) => R, b: any[]): (arg: U) => R;

// @public
export function boolAttr(attrName: string, boolValueObs: BindableValue<boolean>): DomElementMethod;

// @public
export function boolAttrElem(elem: Element, attrName: string, boolValue: boolean): void;

// @public
export function bundleChanges<T>(func: () => T): T;

// @public (undocumented)
export type ChangeCB = (hasListeners: boolean) => void;

// @public
export function cls(className: string, boolValue?: BindableValue<boolean>): DomElementMethod;

// @public (undocumented)
export function cls(className: BindableValue<string>): DomElementMethod;

// @public
export function clsElem(elem: Element, className: string, boolValue?: boolean): void;

// @public
export function clsPrefix(prefix: string, className: string, boolValue?: BindableValue<boolean>): DomElementMethod;

// @public (undocumented)
export function clsPrefix(prefix: string, className: BindableValue<string>): DomElementMethod;

// @public (undocumented)
export class Computed<T> extends Observable<T> {
    constructor(callback: (use: UseCBOwner, ...args: any[]) => T, dependencies: ISubscribable[]);
    // Warning: (ae-forgotten-export) The symbol "Owner" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static create<T>(owner: Owner<T>, cb: (use: UseCBOwner) => T): Computed<T>;
    // (undocumented)
    static create<T, A>(owner: Owner<T>, a: BaseObservable<A>, cb: (use: UseCBOwner, a: A) => T): Computed<T>;
    // (undocumented)
    static create<T, A, B>(owner: Owner<T>, a: BaseObservable<A>, b: BaseObservable<B>, cb: (use: UseCBOwner, a: A, b: B) => T): Computed<T>;
    // (undocumented)
    static create<T, A, B, C>(owner: Owner<T>, a: BaseObservable<A>, b: BaseObservable<B>, c: BaseObservable<C>, cb: (use: UseCBOwner, a: A, b: B, c: C) => T): Computed<T>;
    // (undocumented)
    static create<T, A, B, C, D>(owner: Owner<T>, a: BaseObservable<A>, b: BaseObservable<B>, c: BaseObservable<C>, d: BaseObservable<D>, cb: (use: UseCBOwner, a: A, b: B, c: C, d: D) => T): Computed<T>;
    // (undocumented)
    static create<T, A, B, C, D, E>(owner: Owner<T>, a: BaseObservable<A>, b: BaseObservable<B>, c: BaseObservable<C>, d: BaseObservable<D>, e: BaseObservable<E>, cb: (use: UseCBOwner, a: A, b: B, c: C, d: D, e: E) => T): Computed<T>;
    dispose(): void;
    // @internal
    _getDepItem(): DepItem;
    onWrite(writeFunc: (value: T) => void): Computed<T>;
    set(value: T): void;
}

// @public
export function computed<T>(cb: (use: UseCBOwner) => T): Computed<T>;

// @public (undocumented)
export function computed<T, A>(a: BaseObservable<A>, cb: (use: UseCBOwner, a: A) => T): Computed<T>;

// @public (undocumented)
export function computed<T, A, B>(a: BaseObservable<A>, b: BaseObservable<B>, cb: (use: UseCBOwner, a: A, b: B) => T): Computed<T>;

// @public (undocumented)
export function computed<T, A, B, C>(a: BaseObservable<A>, b: BaseObservable<B>, c: BaseObservable<C>, cb: (use: UseCBOwner, a: A, b: B, c: C) => T): Computed<T>;

// @public (undocumented)
export function computed<T, A, B, C, D>(a: BaseObservable<A>, b: BaseObservable<B>, c: BaseObservable<C>, d: BaseObservable<D>, cb: (use: UseCBOwner, a: A, b: B, c: C, d: D) => T): Computed<T>;

// @public (undocumented)
export function computed<T, A, B, C, D, E>(a: BaseObservable<A>, b: BaseObservable<B>, c: BaseObservable<C>, d: BaseObservable<D>, e: BaseObservable<E>, cb: (use: UseCBOwner, a: A, b: B, c: C, d: D, e: E) => T): Computed<T>;

// @public
export class ComputedArray<T, U> extends ObsArray<U> {
    constructor(obsArr: BaseObservable<T[]> | Observable<BaseObservable<T[]>>, _mapper: (item: T, index: number, arr: ComputedArray<T, U>) => U);
    // (undocumented)
    dispose(): void;
}

// @public
export function computedArray<T, U>(obsArr: BaseObservable<T[]> | Observable<BaseObservable<T[]>>, mapper: (item: T, index: number, arr: ComputedArray<T, U>) => U): ObsArray<U>;

// @public (undocumented)
export type ComputedCallback<T> = (use: UseCBOwner, ...args: any[]) => T;

// Warning: (ae-forgotten-export) The symbol "DomCreatorArgs" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function create<Fn extends IDomCreator<any[]>>(fn: Fn, ...args: DomCreatorArgs<Fn>): DomContents;

// @public (undocumented)
export function data(key: string, valueObs: BindableValue<any>): DomMethod;

// @public
export function dataElem(elem: Node, key: string, value: any): void;

// @public
export abstract class Disposable implements IDisposable, IDisposableOwner {
    constructor();
    autoDispose<T extends IDisposable>(obj: T): T;
    static create<T extends new (...args: any[]) => any>(this: T, owner: IDisposableOwnerT<InstanceType<T>> | null, ...args: ConstructorParameters<T>): InstanceType<T>;
    dispose(): void;
    isDisposed(): boolean;
    // Warning: (ae-forgotten-export) The symbol "DisposeListener" needs to be exported by the entry point index.d.ts
    onDispose<T>(callback: (this: T) => void, context?: T): DisposeListener;
    wipeOnDispose(): void;
}

// @internal (undocumented)
export function _disposeNode(node: Node): void;

// @public
export function dom<Tag extends TagName>(tagString: Tag, ...args: IDomArgs<TagElem<Tag>>): TagElem<Tag>;

// @public (undocumented)
export namespace dom {
    const // Warning: (ae-forgotten-export) The symbol "_domImpl" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    svg: typeof _domImpl.svg;
    const // (undocumented)
    frag: typeof _domImpl.frag;
    const // (undocumented)
    update: typeof _domImpl.update;
    const // (undocumented)
    find: typeof _domImpl.find;
    const // (undocumented)
    findAll: typeof _domImpl.findAll;
    const // Warning: (ae-forgotten-export) The symbol "_domDispose" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    domDispose: typeof _domDispose.domDispose;
    const // (undocumented)
    onDisposeElem: typeof _domDispose.onDisposeElem;
    const // (undocumented)
    onDispose: typeof _domDispose.onDispose;
    const // (undocumented)
    autoDisposeElem: typeof _domDispose.autoDisposeElem;
    const // (undocumented)
    autoDispose: typeof _domDispose.autoDispose;
    const // Warning: (ae-forgotten-export) The symbol "_domMethods" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    attrsElem: typeof _domMethods.attrsElem;
    const // (undocumented)
    attrs: typeof _domMethods.attrs;
    const // (undocumented)
    attrElem: typeof _domMethods.attrElem;
    const // (undocumented)
    attr: typeof _domMethods.attr;
    const // (undocumented)
    boolAttrElem: typeof _domMethods.boolAttrElem;
    const // (undocumented)
    boolAttr: typeof _domMethods.boolAttr;
    const // (undocumented)
    textElem: typeof _domMethods.textElem;
    const // (undocumented)
    text: typeof _domMethods.text;
    const // (undocumented)
    styleElem: typeof _domMethods.styleElem;
    const // (undocumented)
    style: typeof _domMethods.style;
    const // (undocumented)
    propElem: typeof _domMethods.propElem;
    const // (undocumented)
    prop: typeof _domMethods.prop;
    const // (undocumented)
    showElem: typeof _domMethods.showElem;
    const // (undocumented)
    show: typeof _domMethods.show;
    const // (undocumented)
    hideElem: typeof _domMethods.hideElem;
    const // (undocumented)
    hide: typeof _domMethods.hide;
    const // (undocumented)
    clsElem: typeof _domMethods.clsElem;
    const // (undocumented)
    cls: typeof _domMethods.cls;
    const // (undocumented)
    clsPrefix: typeof _domMethods.clsPrefix;
    const // (undocumented)
    dataElem: typeof _domMethods.dataElem;
    const // (undocumented)
    data: typeof _domMethods.data;
    const // (undocumented)
    getData: typeof _domMethods.getData;
    const // Warning: (ae-forgotten-export) The symbol "_domComputed" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    replaceContent: typeof _domComputed.replaceContent;
    const // (undocumented)
    domComputed: typeof _domComputed.domComputed;
    const // (undocumented)
    domComputedOwned: typeof _domComputed.domComputedOwned;
    const // (undocumented)
    maybe: typeof _domComputed.maybe;
    const // (undocumented)
    maybeOwned: typeof _domComputed.maybeOwned;
    const // Warning: (ae-forgotten-export) The symbol "_domForEach" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    forEach: typeof _domForEach.forEach;
    const // Warning: (ae-forgotten-export) The symbol "_domComponent" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    create: typeof _domComponent.create;
    const // Warning: (ae-forgotten-export) The symbol "domevent" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    onElem: typeof domevent.onElem;
    const // (undocumented)
    on: typeof domevent.on;
    const // (undocumented)
    onMatchElem: typeof domevent.onMatchElem;
    const // (undocumented)
    onMatch: typeof domevent.onMatch;
    const // (undocumented)
    onKeyElem: typeof domevent.onKeyElem;
    const // (undocumented)
    onKeyPress: typeof domevent.onKeyPress;
    const // (undocumented)
    onKeyDown: typeof domevent.onKeyDown;
}

// @public (undocumented)
export type DomArg<T = Node> = Node | string | void | null | undefined | IDomArgs<T> | DomMethod<T> | (T extends Element ? IAttrObj : never);

// @public (undocumented)
export type DomComponentReturn = DomContents | IDomComponent;

// @public (undocumented)
export type DomComputed = [Node, Node, DomMethod];

// @public
export function domComputed(valueObs: BindableValue<Exclude<DomArg, DomMethod>>): DomComputed;

// @public (undocumented)
export function domComputed<T>(valueObs: BindableValue<T>, contentFunc: (val: T) => DomContents): DomComputed;

// @public
export function domComputedOwned<T>(valueObs: BindableValue<T>, contentFunc: (owner: MultiHolder, val: T) => DomContents): DomComputed;

// @public (undocumented)
export type DomContents = Node | string | DomComputed | void | null | undefined | IDomContentsArray;

// @public (undocumented)
export type DomCreateFunc<R, Args extends IDomArgs<R> = IDomArgs<R>> = (...args: Args) => R;

// @public
export function domDispose(node: Node): void;

// @public
export const domDisposeHooks: IDomDisposeHooks;

// @public (undocumented)
export type DomElementArg = DomArg<HTMLElement>;

// @public (undocumented)
export type DomElementMethod = DomMethod<HTMLElement>;

// @public (undocumented)
export type DomMethod<T = Node> = (elem: T) => DomArg<T> | void;

// @public (undocumented)
export class Emitter extends LLink {
    constructor();
    addListener<T>(callback: ListenerCB<T>, optContext?: T): Listener;
    dispose(): void;
    emit(...args: any[]): void;
    hasListeners(): boolean;
    setChangeCB(changeCB: ChangeCB, optContext?: any): void;
    // @internal
    _triggerChangeCB(): void;
}

// @public (undocumented)
export type EventCB<E extends Event = Event, T extends EventTarget = EventTarget> = (this: void, event: E, elem: T) => void;

// @public (undocumented)
export type EventName = keyof HTMLElementEventMap;

// @public (undocumented)
export type EventType<E extends EventName | string> = E extends EventName ? HTMLElementEventMap[E] : Event;

// @public
export function find(selector: string): Element | null;

// @public
export function findAll(selector: string): NodeListOf<Element>;

// @public
export function forEach<T>(obsArray: MaybeObsArray<T>, itemCreateFunc: (item: T) => Node | null): DomContents;

// @public
export function frag(...args: IDomArgs<DocumentFragment>): DocumentFragment;

// @public
export function fromKo<KObs extends IKnockoutObservable<any>>(koObs: KObs): Observable<InferKoType<KObs>>;

// @public (undocumented)
export function getData(elem: Node, key: string): any;

// @public (undocumented)
export function hide(boolValueObs: BindableValue<boolean>): DomElementMethod;

// @public
export function hideElem(elem: HTMLElement, boolValue: boolean): void;

// @public
export class Holder<T extends IDisposable> implements IDisposable, IDisposableOwner {
    autoDispose(obj: T): T;
    clear(): void;
    // (undocumented)
    static create<T extends IDisposable>(owner: IDisposableOwnerT<Holder<T>> | null): Holder<T>;
    dispose(): void;
    get(): T | null;
    isEmpty(): boolean;
    // (undocumented)
    protected _owned: T | null;
    release(): IDisposable | null;
}

// @public (undocumented)
export interface IAttrObj {
    // (undocumented)
    [attrName: string]: string | boolean | null | undefined;
}

// @public (undocumented)
export interface IClsName {
    // (undocumented)
    className: string;
    // (undocumented)
    cls: typeof cls;
}

// @public
export interface IDisposable {
    // (undocumented)
    dispose(): void;
}

// @public
export interface IDisposableCtor<Derived, CtorArgs extends any[]> {
    // (undocumented)
    new (...args: CtorArgs): Derived;
    // (undocumented)
    create<T extends new (...args: any[]) => any>(this: T, owner: IDisposableOwnerT<InstanceType<T>> | null, ...args: ConstructorParameters<T>): InstanceType<T>;
}

// @public
export interface IDisposableOwner {
    // (undocumented)
    autoDispose(obj: IDisposable): void;
}

// @public
export interface IDisposableOwnerT<T extends IDisposable> {
    // (undocumented)
    autoDispose(obj: T): void;
}

// @public (undocumented)
export interface IDomArgs<T = Node> extends Array<DomArg<T>> {
}

// @public (undocumented)
export interface IDomComponent {
    // (undocumented)
    buildDom(): DomContents;
}

// @public (undocumented)
export interface IDomContentsArray extends Array<DomContents> {
}

// @public (undocumented)
export interface IDomCreateClass<Args extends any[]> {
    // (undocumented)
    new (...args: Args): DomComponentReturn;
    // (undocumented)
    create: IDomCreateFunc<Args>;
}

// @public (undocumented)
export type IDomCreateFunc<Args extends any[]> = (owner: MultiHolder, ...args: Args) => DomComponentReturn;

// @public (undocumented)
export type IDomCreator<Args extends any[]> = IDomCreateFunc<Args> | IDomCreateClass<Args>;

// @public (undocumented)
export interface IDomDisposeHooks {
    // (undocumented)
    disposeNode: (node: Node) => void;
    // (undocumented)
    disposeRecursive: (node: Node) => void;
}

// @public (undocumented)
export interface IInputOptions {
    // (undocumented)
    isValid?: Observable<boolean>;
    // (undocumented)
    onInput?: boolean;
}

// @public (undocumented)
export interface IKeyHandlers<T extends HTMLElement = HTMLElement> {
    // (undocumented)
    [key: string]: (this: void, ev: KeyboardEvent, elem: T) => void;
}

// @public (undocumented)
export interface IKnockoutModule {
    // (undocumented)
    cleanNode(node: Node): void;
    // (undocumented)
    observable<T>(value: T): IKnockoutObservable<T>;
}

// @public (undocumented)
export interface IKnockoutObservable<T> extends IKnockoutReadObservable<T> {
    // (undocumented)
    (val: T): void;
}

// @public (undocumented)
export interface IKnockoutReadObservable<T> {
    // (undocumented)
    (): T;
    // (undocumented)
    getSubscriptionsCount(): number;
    // (undocumented)
    peek(): T;
    // (undocumented)
    subscribe(callback: (newValue: T) => void, target?: any, event?: "change"): any;
}

// @public (undocumented)
export type InferKoType<KObs extends IKnockoutReadObservable<any>> = KObs extends {
    peek(): infer T;
} ? T : never;

// @public (undocumented)
export type InferUseType<TObs extends BaseObservable<any> | IKnockoutReadObservable<any>> = TObs extends BaseObservable<infer T> ? T : TObs extends {
    peek(): infer U;
} ? U : never;

// @public (undocumented)
export type INodeFunc = (node: Node) => void;

// @public
export function input(obs: Observable<string>, options: IInputOptions, ...args: IDomArgs<HTMLInputElement>): HTMLInputElement;

// @public
export interface IObsArraySplice<T> {
    // (undocumented)
    deleted: T[];
    // (undocumented)
    numAdded: number;
    // (undocumented)
    start: number;
}

// @public (undocumented)
export type IOption<T> = (T & string) | IOptionFull<T>;

// @public (undocumented)
export interface IOptionFull<T> {
    // (undocumented)
    disabled?: boolean;
    // (undocumented)
    label: string;
    // (undocumented)
    value: T;
}

// @public (undocumented)
export type ISpliceListener<T, C> = (this: C, val: T[], prev: T[], change?: IObsArraySplice<T>) => void;

// @public (undocumented)
export type ISubscribable = ISubscribableObs | IKnockoutReadObservable<any>;

// @public (undocumented)
export interface ISubscribableObs {
    // (undocumented)
    addListener(callback: (val: any, prev: any) => void, optContext?: object): Listener;
    // (undocumented)
    get(): any;
    // (undocumented)
    _getDepItem(): DepItem | null;
}

// @public (undocumented)
export type KeyEventType = 'keypress' | 'keyup' | 'keydown';

// @public
export function keyframes(styles: string): string;

// @public
export class KoWrapObs<T> extends Observable<T> {
    constructor(_koObs: IKnockoutObservable<T>);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get(): T;
    // (undocumented)
    set(value: T): void;
}

// @public
export class Listener extends LLink {
    constructor(emitter: Emitter, callback: ListenerCB<any>, context?: any);
    // (undocumented)
    static callAll(begin: LLink, end: LLink, args: any[]): void;
    // (undocumented)
    dispose(): void;
}

// @public
export type ListenerCB<T> = (this: T, ...args: any[]) => void;

// @public (undocumented)
export class LiveIndex extends Observable<number | null> {
    constructor(_obsArray: ObsArray<any>, initialIndex?: number);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    set(index: number | null): void;
    // (undocumented)
    setLive(value: boolean): void;
}

// @public
export class LLink {
    constructor();
    // (undocumented)
    protected _disposeList(): void;
    // (undocumented)
    protected _insertBefore(next: LLink, node: LLink): void;
    // (undocumented)
    isDisposed(): boolean;
    // (undocumented)
    protected _next: LLink | null;
    // (undocumented)
    protected _prev: LLink | null;
    // (undocumented)
    protected _removeNode(node: LLink): void;
}

// @public
export function makeLiveIndex<T>(owner: IDisposableOwnerT<LiveIndex> | null, obsArr: ObsArray<T>, initialIndex?: number): LiveIndex;

// @public
export function makeTestId(prefix: string): TestId;

// @public
export function maybe<T>(boolValueObs: BindableValue<T>, contentFunc: (val: NonNullable<T>) => DomContents): DomComputed;

// @public
export type MaybeObsArray<T> = BaseObservable<T[]> | T[];

// @public
export function maybeOwned<T>(boolValueObs: BindableValue<T>, contentFunc: (owner: MultiHolder, val: NonNullable<T>) => DomContents): DomComputed;

// @public
export class MultiHolder extends Disposable {
}

// @public
export class MutableObsArray<T> extends ObsArray<T> {
    // (undocumented)
    pop(): T | undefined;
    // (undocumented)
    push(...args: T[]): number;
    // (undocumented)
    shift(): T | undefined;
    // (undocumented)
    splice(start: number, deleteCount?: number, ...newValues: T[]): T[];
    // (undocumented)
    unshift(...args: T[]): number;
}

// @public
export const noTestId: TestId;

// @public
export class ObsArray<T> extends BaseObservable<T[]> {
    // (undocumented)
    addListener(callback: ISpliceListener<T, void>): Listener;
    // (undocumented)
    addListener<C>(callback: ISpliceListener<T, C>, context: C): Listener;
    // (undocumented)
    autoDispose(value: T & IDisposable): T & IDisposable;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    protected _disposeOwned(splice?: IObsArraySplice<T>): void;
    // (undocumented)
    protected _setWithSplice(value: T[], splice: IObsArraySplice<T>): void;
}

// @public
export function obsArray<T>(value?: T[]): MutableObsArray<T>;

// @public
export class Observable<T> extends BaseObservable<T> implements IDisposableOwnerT<T & IDisposable> {
    autoDispose(value: T & IDisposable): T & IDisposable;
    static create<T>(owner: IDisposableOwnerT<Observable<T>> | null, value: T): Observable<T>;
    // (undocumented)
    protected _disposeOwned(): void;
    // (undocumented)
    static holder<T>(value: T & IDisposable): Observable<T>;
}

// @public
export function observable<T>(value: T): Observable<T>;

// @public
export function obsHolder<T>(value: T & IDisposable): Observable<T>;

// @public (undocumented)
export function on<E extends EventName | string, T extends EventTarget>(eventType: E, callback: EventCB<EventType<E>, T>, { useCapture }?: {
    useCapture?: boolean | undefined;
}): DomMethod<T>;

// @public (undocumented)
export function onDispose(disposerFunc: INodeFunc): (elem: Node) => void;

// @public
export function onDisposeElem(elem: Node, disposerFunc: INodeFunc): void;

// @public
export function onElem<E extends EventName | string, T extends EventTarget>(elem: T, eventType: E, callback: EventCB<EventType<E>, T>, { useCapture }?: {
    useCapture?: boolean | undefined;
}): IDisposable;

// @public (undocumented)
export function onKeyDown<T extends HTMLElement>(keyHandlers: IKeyHandlers<T>): DomMethod<T>;

// @public
export function onKeyElem<T extends HTMLElement>(elem: T, evType: KeyEventType, keyHandlers: IKeyHandlers<T>): IDisposable;

// @public (undocumented)
export function onKeyPress<T extends HTMLElement>(keyHandlers: IKeyHandlers<T>): DomMethod<T>;

// @public (undocumented)
export function onMatch(selector: string, eventType: string, callback: EventCB, { useCapture }?: {
    useCapture?: boolean | undefined;
}): DomElementMethod;

// @public
export function onMatchElem(elem: EventTarget, selector: string, eventType: string, callback: EventCB, { useCapture }?: {
    useCapture?: boolean | undefined;
}): IDisposable;

// @public (undocumented)
export function prop<T>(property: string, valueObs: BindableValue<T>): DomMethod;

// @public
export function propElem<T>(elem: Node, property: string, value: T): void;

// @public (undocumented)
export class PureComputed<T> extends Observable<T> {
    constructor(callback: (use: UseCB, ...args: any[]) => T, dependencies: ReadonlyArray<ISubscribable>);
    dispose(): void;
    // (undocumented)
    get(): T;
    // (undocumented)
    _getDepItem(): DepItem;
    onWrite(writeFunc: (value: T) => void): PureComputed<T>;
    set(value: T): void;
}

// @public
export function pureComputed<T>(cb: (use: UseCB) => T): PureComputed<T>;

// @public (undocumented)
export function pureComputed<A, T>(a: Observable<A>, cb: (use: UseCB, a: A) => T): PureComputed<T>;

// @public (undocumented)
export function pureComputed<A, B, T>(a: Observable<A>, b: Observable<B>, cb: (use: UseCB, a: A, b: B) => T): PureComputed<T>;

// @public (undocumented)
export function pureComputed<A, B, C, T>(a: Observable<A>, b: Observable<B>, c: Observable<C>, cb: (use: UseCB, a: A, b: B, c: C) => T): PureComputed<T>;

// @public (undocumented)
export function pureComputed<A, B, C, D, T>(a: Observable<A>, b: Observable<B>, c: Observable<C>, d: Observable<D>, cb: (use: UseCB, a: A, b: B, c: C, d: D) => T): PureComputed<T>;

// @public (undocumented)
export function pureComputed<A, B, C, D, E, T>(a: Observable<A>, b: Observable<B>, c: Observable<C>, d: Observable<D>, e: Observable<E>, cb: (use: UseCB, a: A, b: B, c: C, d: D, e: E) => T): PureComputed<T>;

// @public
export function replaceContent(nodeBefore: Node, nodeAfter: Node, content: DomContents): void;

// @public
export function select<T>(obs: Observable<T>, optionArray: MaybeObsArray<IOption<T>>, options?: {
    defLabel?: string;
}): HTMLSelectElement;

// @public
export function setDisposeOwner<T extends IDisposable>(owner: IDisposableOwnerT<T> | null, obj: T): T;

// @public
export function setupKoDisposal(ko: IKnockoutModule): void;

// @public (undocumented)
export function show(boolValueObs: BindableValue<boolean>): DomElementMethod;

// @public
export function showElem(elem: HTMLElement, boolValue: boolean): void;

// @public (undocumented)
export function style(property: string, valueObs: BindableValue<string>): DomElementMethod;

// @public
export function styled<Tag extends TagName>(tag: Tag, styles: string): DomCreateFunc<TagElem<Tag>> & IClsName;

// @public (undocumented)
export function styled<Args extends any[], R extends Element>(creator: (...args: Args) => R, styles: string): typeof creator & IClsName;

// @public
export function styleElem(elem: Element, property: string, value: string): void;

// @public
export function subscribe(cb: (use: UseCB) => void): Subscription;

// @public (undocumented)
export function subscribe<A>(a: BaseObservable<A>, cb: (use: UseCB, a: A) => void): Subscription;

// @public (undocumented)
export function subscribe<A, B>(a: BaseObservable<A>, b: BaseObservable<B>, cb: (use: UseCB, a: A, b: B) => void): Subscription;

// @public (undocumented)
export function subscribe<A, B, C>(a: BaseObservable<A>, b: BaseObservable<B>, c: BaseObservable<C>, cb: (use: UseCB, a: A, b: B, c: C) => void): Subscription;

// @public (undocumented)
export function subscribe<A, B, C, D>(a: BaseObservable<A>, b: BaseObservable<B>, c: BaseObservable<C>, d: BaseObservable<D>, cb: (use: UseCB, a: A, b: B, c: C, d: D) => void): Subscription;

// @public (undocumented)
export function subscribe<A, B, C, D, E>(a: BaseObservable<A>, b: BaseObservable<B>, c: BaseObservable<C>, d: BaseObservable<D>, e: BaseObservable<E>, cb: (use: UseCB, a: A, b: B, c: C, d: D, e: E) => void): Subscription;

// @public
export function subscribeBindable<KObs extends IKnockoutReadObservable<any>>(valueObs: KObs, callback: (val: InferKoType<KObs>) => void): IDisposable | null;

// @public (undocumented)
export function subscribeBindable<T>(valueObs: BindableValue<T>, callback: (val: T) => void): IDisposable | null;

// @public
export function subscribeElem<T>(elem: Node, valueObs: BindableValue<T>, callback: (newVal: T, oldVal?: T) => void): void;

// @public (undocumented)
export class Subscription {
    constructor(callback: (use: UseCB, ...args: any[]) => void, dependencies: ReadonlyArray<ISubscribable>, owner?: any);
    dispose(): void;
    // @internal
    _getDepItem(): DepItem;
}

// @public
export function svg(tagString: string, ...args: IDomArgs<SVGElement>): SVGElement;

// @public (undocumented)
export type TagElem<T extends TagName> = T extends keyof HTMLElementTagNameMap ? HTMLElementTagNameMap[T] : HTMLElement;

// @public (undocumented)
export type TagName = keyof HTMLElementTagNameMap | string;

// @public
export type TestId = (name: string) => DomElementMethod | null;

// @public (undocumented)
export function text(valueObs: BindableValue<string>): DomMethod;

// @public
export function textElem(elem: Node, value: string): void;

// @public
export function toKo<T>(knockout: IKnockoutModule, grainObs: Observable<T>): IKnockoutObservable<T>;

// @public
export function update<T extends Node, Args extends IDomArgs<T>>(elem: T, ...args: Args): T;

// @public (undocumented)
export type UseCB = <TObs extends BaseObservable<any> | IKnockoutReadObservable<any>>(obs: TObs) => InferUseType<TObs>;

// @public (undocumented)
export interface UseCBOwner extends UseCB {
    // (undocumented)
    owner: IDisposableOwner;
}

// (No @packageDocumentation comment for this package)

```
